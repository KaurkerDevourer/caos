# Кэши

Когерентность кэшей (Cache Coherence) — это механизм, который гарантирует, что все процессоры в многопроцессорной системе видят последовательные (согласованные) значения данных, даже если они кэшируются локально.

Основной протокол, обеспечивающий когерентность — **MESI** (Modified, Exclusive, Shared, Invalid).

Каждая кэш-линия может находиться в одном из 4 состояний:
| Состояние	| Описание |
| --------- | -------- |
| M (Modified) | Данные изменены только в этом кэше. В памяти — устаревшие. |
| E (Exclusive) | Данные есть только в этом кэше, но не изменены. В памяти — актуальные. |
| S (Shared) | Данные есть в нескольких кэшах, все актуальны. |
| I (Invalid) | Данные устарели или отсутствуют. |

Симулятор MESI:
https://www.scss.tcd.ie/jeremy.jones/VivioJS/caches/MESI.htm

Доклад про ring bus:
https://www.cs.cmu.edu/afs/cs/academic/class/15418-s21/www/lectures/11_cachecoherence1.pdf

Картиночка о том как оно там лежит где:
https://al-tm.ru/vsi/24286_screenshot%202019-03-07%20001.png


## Механизмы когерентности кэшей: Snooping (шина) vs Directory-Based (L3)

| Характеристика               | Snooping (шина)                          | Directory-Based (L3)                   |
|------------------------------|------------------------------------------|----------------------------------------|
| **Основной принцип**         | Все ядра "подслушивают" общую шину       | L3 ведёт каталог владельцев кэш-линий  |
| **Где хранятся состояния**   | В каждом кэше (L1/L2)                    | В каталоге L3 + дублируется в кэшах    |
| **Как обнаруживается конфликт** | Через широковещательные запросы на шине | Через проверку каталога в L3           |
| **Типичная задержка**        | 40-100 циклов (шина может стать узким местом) | 20-60 циклов (меньше трафика)       |
| **Масштабируемость**         | До 8-16 ядер                             | До 64+ ядер                            |
| **Трафик**                   | Высокий (широковещательные запросы)      | Низкий (точечные инвалидации)          |
| **Аппаратные затраты**       | Дешевле                                  | Дороже (нужен каталог в L3)            |
| **Примеры архитектур**       | Intel Core (Ring Bus), AMD Zen (Infinity Fabric) | Intel Xeon, AMD EPYC           |


# Атомики

## Основные методы

| Метод                          | Описание                                                                 | Аналог в ассемблере (x86)       |
|--------------------------------|-------------------------------------------------------------------------|----------------------------------|
| `load(order)`                  | Атомарное чтение значения                                               | `mov` + барьер памяти           |
| `store(val, order)`            | Атомарная запись значения                                               | `mov` + барьер памяти           |
| `fetch_add(val, order)`        | Атомарное сложение (возвращает старое значение)                         | `LOCK XADD`                     |
| `fetch_sub(val, order)`        | Атомарное вычитание                                                     | `LOCK XADD` (с отрицательным числом) |
| `exchange(val, order)`         | Атомарная замена значения                                               | `LOCK XCHG`                     |
| `compare_exchange_strong()`    | Сравнение и замена (CAS)                                                | `LOCK CMPXCHG`                  |
| `test_and_set(order)`          | Установка флага в `true` (для `atomic_flag`)                            | `LOCK BTS` 

## Модели памяти (`memory_order`)

| Модель                  | Гарантии                                                                 | Пример использования                     |
|-------------------------|-------------------------------------------------------------------------|------------------------------------------|
| `relaxed`               | Только атомарность, нет порядка операций                                | Счётчики, метрики                        |
| `consume` (deprecated)  | Зависимые операции видны (удалён в C++20)                              | Чтение указателей после публикации       |
| `acquire`               | Все операции ПОСЛЕ `load` видны после этой точки                        | Захват опубликованных данных             |
| `release`               | Все операции ДО `store` видны до этой точки                             | Публикация данных для других потоков     |
| `acq_rel`               | Комбинация `acquire` и `release` (для RMW-операций)                    | `compare_exchange`, `fetch_add`          |
| `seq_cst`               | Полная последовательная согласованность (по умолчанию)                 | Когда нужны строгие гарантии порядка     |

memory_order на cppreference: 
https://en.cppreference.com/w/cpp/atomic/memory_order
