## man 2 fork
```
pid_t fork();
```

fork создает процесс-потомок, который отличается от родительского только значениями PID (идентификатор процесса) и PPID (идентификатор родительского процесса), а также тем фактом, что счетчики использования ресурсов установлены в 0. Блокировки файлов и сигналы, ожидающие обработки, не наследуются.

Это в том числе означает, что процесс-потомок хранит копию родительского дескриптора, а так как дескрипторы ни что иное как указатели, то, например, чтения из файла таким дескриптором в процессе-потомке будет влиять на родительский дескриптор. См `fork_fd.c`

Под Linux fork реализован с помощью "копирования страниц при записи" (copy-on-write, COW), поэтому расходы на fork сводятся к копирования таблицы страниц родителя и созданию уникальной структуры, описывающей задачу.  

При успешном завершении 
* родителю возвращается PID процесса-потомка
* процессу-потомку возвращается 0. 

При неудаче родительскому процессу возвращается -1, процесс-потомок не создается, а значение errno устанавливается должным образом. 

## man 2 wait

```
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);
```

Функция **wait** приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не завершится. 

Если дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби"), то функция немедленно возвращается.

Функция **waitpid** приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, указанный в параметре pid, не завершит выполнение.

## gdb
```
set follow-fork-mode child
set detach-on-fork off
info inferiors
inferior
detach inferiors
```
